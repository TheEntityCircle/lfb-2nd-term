# Лабораторная 5
Прежде, чем двинуться дальше, к большим и интересным штукам *(например, сборке Heroes III из исходников, а еще многим компилятор до новой версии обновить надо, мы и его из исходников соберем)*, нам нужно покрыть еще одну важную и большую тему.
Библиотеки. 
Программистам часто приходится работать с чужим кодом, и библиотеки - это штатный способ получать огромные объемы чужого кода в удобном виде.
Правда удобном, надо только немного привыкнуть.
Если вы поймете, как работают статические и динамические библиотеки, да еще и с путями не будете путаться, то и проблем с настройкой и установкой рабочего окружения у вас будет на порядок меньше.
В любой операционной системе.

## Что делаем
Смотрим, что такое библиотеки - какие они бывают, как их делать и как их подключать к вашему коду.

### 0. Флаги компиляции.
Это скорее технический момент, и раньше флаги компиляции в том или ином виде мелькали, но давайте соберем все вместе и разберемся более серьезно.

Как вы уже поняли, флаги - это модификаторы, которые мы задаем программе в командной строке.
В том числе и компилятору. 
У разных компиляторов флаги, вообще говоря, могут быть разные (хоть и похожие).
Мы рассматриваем g++.

Начнем с флага, которым вы уже пользовались - ```-o```. 
Он задает название итогового файла (output) и будет трактовать как название любое написанное следом слово.
Например, ```g++ -o hello hello.cpp``` или ```g++ hello.cpp -o hello``` - порядок флагов не важен, но название остается "приклеенным" к флагу как его "аргумент".

Следующий полезный флаг (точнее, несколько флагов) позволяет ускорять работу вашего кода практически без усилий с вашей стороны.
Флаги ```-O0```, ```-O1```, ```-O2```, ```-O3``` включают разные уровни оптимизации:
- ```-O0``` без оптимизации, вариант по умолчанию;
- ```-O1``` немного подрезает инструкции, но больших изменений не делает;
- ```-O2``` сильно ускоряет код, местами переделывает логику, но гарантированно ничего не ломает (если сам код написан корректно);
- ```-O3``` добавляет к предыдущему варианту некоторые агрессивные оптимизации, которые могут испортить точность, поэтому в научных расчетах с ним надо быть осторожно;
- ```-Ofast``` будет еще быстрее, но может сильно поломать точность - для игр ок, для научных расчетов не ок.
Важный момент насчет оптимизации. 
Если ваш код "ну чучуть" некорректен - например, вылезает на несколько байтов в сторону от массива в куче - оптимизация может его "сломать".
*В кавычках, потому что вообще-то код и был сломан, просто под О0 вы этого не замечали - например, там было не очень эффективное распределение памяти и зазоры между данными, вы попадали в них, и все типа работало, а вот более эффективное распределение памяти или перестановка переменных местами вам уже ничего не простили.*

*Для начала, чтобы начать работать с оптимизациями, такого описания вам будет достаточно.
Подробнее про то, как оно устроено, будет в следующем семестре про ассемблер, потому что без рассматриваемых там терминов, концепций и инструментов любой разговор про оптимизацию превращается в странную магию.
С ассемблером оно будет довольно просто и понятно.*

*Кому хочется почитать побольше уже сейчас - вот документация, тут все написано человеческим языком* <https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html> 
*Но какие-то моменты еще могут быть непонятны.*

Флаг ```-g```, очень полезный при отладке, добавляет дебаговые символы.
Они позволяют отслеживать команды в бинарнике обратно до строк кода С++.
Например, встроенный в среду разработки дебаггер может с их помощью изображать, что он исполняет по очереди строки кода на С++.
А еще они позволяют valgrind говорить вам, в какой именно строчке кода произошла ошибка.
Учтите, что этот флаг нормально работает только с О0 - любая оптимизация перекраивает код, и вернуться обратно в строки плюсов получается не всегда.
Если очень хочется, чтобы дебаговая версия работала побыстрее - используйте флаг ```-Og```.
Тогда компилятор ускорит то, что может, не теряя отслеживания строк.

Флаги стандартов: например ```-std=c++17```включает 17 стандарт.
У разных механик С++ и сущностей из STL может быть разное время жизни с точки зрения стандартов.
Например, одна функция может быть введена в с++03 и удалена в с++17 (см. <https://en.cppreference.com/w/cpp/memory/auto_ptr>).
Время жизни лучше проверять по cppreference, там вполне актуальная информация (можно даже посмотреть, есть ли в вашем компиляторе конкретная механика из стандарта <https://en.cppreference.com/w/cpp/compiler_support>, свою версию можно посмотреть так: ```g++ -v```).

Это были флаги, которые вам сейчас нужнее всего. 
Есть те, которые нужны поменьше - например, переключать уровень предупреждений (warnings).
Их можете погуглить.
Есть специализированные, типа указания путей или библиотек, их мы рассмотрим в следующих пунктах.

Проверьте все эти флаги на несчастном yet_another_educational_cowsay.
Скорость работы можете смотреть утилитой time, про нее можете почитать в прошлой лабе (пункт #7).

### 1. Статические библиотеки.
После этапа компиляции многофайлового проекта вы получаете набор объектных файлов.
Иногда вы понимаете, что часть этих файлов можно сгруппировать в некоторую единую сущность - она редко перекомпилируется, большая часть кода использует только друг друга, а внешний код вызывает только несколько функций. 
Так появились системные библиотеки и стандартная библиотека STL - это уже кем-то написанный и заранее скомпилированный код, который вы можете подключить к своему.

Давайте разберемся, как это делается технически, и какие есть варианты.

Первый вариант, самый простой - это статические библиотеки (вы можете еще услышать название "архивы").
При создании библиотеки линкер берет стопку объектных файлов, проверяет наличие всех реализаций, обещанных на этапе компиляции, и собирает все в один большой бинарник - но это будет еще не исполняемый файл, а что-то вроде полуфабриката.
У исполняемого файла должна быть точка входа - функция main.
У библиотеки ее нет - только набор функций.
То есть как объектный файл, только без "обещанных, но не подставленных" реализаций.
Потом эту библиотеку надо слинковать с объектным файлом, в котором есть main - тогда у вас будет нормальный исполняемый файл, который можно запустить.

Давайте пройдем по шагам.
Посмотрите в папку 00\_simple\_static\_library, разберитесь, что делает код, как его собрать и запустить.
Убедитесь в его работоспособности прежде, чем двигаться дальше.
Makefile писать не обязательно, пока что можно обойтись командами непосредственно компилятору.

Теперь попробуем собрать статическую библиотеку, в которой будут наши функции goodbye, anatoly и cherdenko.
Прежде всего, нам нужно скомпилировать файлы goodbye.cpp, anatoly.cpp и cherdenko.cpp, получив объектные файлы.

```g++ -c goodbye.cpp -o goodbye.o```

```g++ -c anatoly.cpp -o anatoly.o```

```g++ -c cherdenko.cpp -o cherdenko.o```

Дальше мы собираем эти объектные файлы в библиотеку командой ```ar```.

```ar -q libSPACE.a goodbye.o anatoly.o cherdenko.o```

- ```ar``` - это стандартная утилита для создания библиотек (сокращение от archive). Полный список возможностей, как обычно, смотреть через ```ar -h```, ```ar --help``` или ```man ar```.  *Так же, как и у cowsay - это все стандартное.*
- ```-q``` - флаг, который говорит добавить в библиотеку объектные файлы (с этим можно поэкспериментировать).
- ```libSPACE.a``` - название библиотеки. ```.a``` является стандартным расширением для статических библиотек в линуксе (собственно, опять archive), в Windows стандартным расширением является ```.lib```.
- ```goodbye.o anatoly.o cherdenko.o``` - файлы, которые мы хотим добавить.

Теперь, когда у нас есть библиотека, мы можем собрать с ней исполняемый файл.
```g++ -o main main.cpp libSPACE.a```
Ничего особо умного, на самом деле.
Мы перечисляет g++ то, что он должен, в конечном счете, добавить в исполняемый файл. 
В одном списке можно перечислять файлы исходников .cpp/.c, объектные файлы .o, статические библиотеки .a - компилятор по расширению разберется, что с чем делать, и в итоге выдаст один исполняемый файл.

Запустите и удостоверьтесь, что все сработало так же, как и до экспериментов с библиотеками.

А теперь давайте немного про пути.
Вы можете сказать компилятору, где искать заголовочные файлы (хедеры, .h) и библиотеки.
Зайдите в папку 01\_another\_directory\_static\_library.
Там лежит точно такой же main.cpp, как и в 00\_simple\_static\_library, давайте его соберем. 
*Если вы удалили или переименовали библиотеку в 00\_simple\_static\_library, ее нужно собрать заново с правильным названием.*

```g++ main.cpp -o main -I ../00_simple_static_library/ -L ../00_simple_static_library/ -lSPACE```

- флаг ```-I ../00_simple_static_library/``` пополняет компилятору список директорий, в которых он ищет хедеры. С точки зрения синтаксиса команды, можно писать относительный путь, можно абсолютный - компилятору без разницы, ориентируйтесь на то, чего хотите добиться. А пробел после ```-I``` можно писать, можно и не писать.
- флаг ```-L ../00_simple_static_library/``` пополняет компилятору список директорий, в которых он ищет библиотеки. Синтаксис аналогичен ```-I```. 
- ```-lSPACE``` а так теперь записывается название библиотеки, чтобы добавленные пути сработали. Такая запись автоматически раскроется - приставит вместо -l правильный путь и приставку lib, а в конец допишет расширение.

Запустите и удостоверьтесь, что все сработало так же, как и до экспериментов с путями.

Можете теперь вернуться в папку 00\_simple\_static\_library и собраться аналогичным образом там:

```g++ main.cpp -o main -L . -lSPACE```

Чтобы сокращенная запись библиотеки сработала, нам пришлось добавить компилятору путь ```.``` - то есть текущую директорию.

*На все бинарники можно смотреть через objdump. 
Вам вряд ли понравится то, что вы увидите, но опознать там ваши функции вообще-то можно.
Использовать вот так:*

```objdump -D lSPACE.a```

**Статическая библиотека копируется в исполняемый файл.**

### 2. Динамические библиотеки.
Давайте рассмотрим чуть более сложный вариант.
Статические библиотеки копируются в исполняемый файл целиком, что увеличивает его размер на диске и занимаемую память при исполнении.
С точки зрения операционной системы, ситуация выглядит довольно глупо - у нее часто бывает запущено много процессов, которые используют одни и те же библиотеки, то есть одни и те же инструкции много раз дублируются в памяти.
Если библиотеку обновили, даже чуть-чуть - все исполняемые файлы, в которых она есть, придется пересобирать.
Жить можно, но не очень удобно.

Динамические библиотеки нужны, чтобы решать эти проблемы.
Когда вы линкуете ваш исполняемый файл с динамической библиотекой, содержимое библиотеки не копируется внутрь - там только проставляются ссылки. 
Содержимое будет получено исполняемым файлом только на этапе запуска.
В момент запуска динамическая библиотека подгрузится в систему, а если ее уже кто-то подгрузил до вас, то ваш исполняемый файл будет использовать эту подгруженную версию. 

**Динамическая библиотека в исполняемый файл не копируется.**

То есть, если у вас будет запущен десяток процессов (можно одинаковых, с одного и того же исполняемого файла, а можно и сильно разных, но использующих ту же библиотеку), они все будут использовать один и тот же кусочек кода, не дублируя его.
Это экономия оперативной памяти (казалось бы, ее много, но если совсем не экономить, то никаких гигабайтов не хватит).

С обновлениями тоже будет попроще.
Если изменилить только реализации, но не заголовки динамической библиотеки, то пересобирать придется только саму эту библиотеку.
Те процессы, которые ее используют, достаточно будет просто перезапустить, и они автоматически получат новую версию.
Если поменяли заголовки (то есть правила вызова функций) или какие-то функции убрали - там, конечно, придется пересобирать все. 
Но это происходит не так уж часто.

Давайте попробуем собрать тот же код в динамическую библиотеку.
Для аккуратности лучше делайте это в 02\_simple\_dynamic\_library.
Код тот же.

В отличие от статической библиотеки, которая собиралось отдельной утилитой ```ar```, динамические делаются тем же ```g++```.
Поэтому вам не обязательно делать руками отдельный этап с генерацией объектных файлов, а писать компилятору сразу исходники.
Вот так:

```g++ -fPIC -shared goodbye.cpp anatoly.cpp cherdenko.cpp -o libSPACE.so```
- флаг ```-fPIC``` заставляет компилятор генерировать не абсолютные адреса функций, а относительные. Без этого динамическая линковка не сработает. 
*А в ассемблере мы заглянем в это подробнее.*
- флаг ```-shared``` говорит компилятору сгенерировать динамическую библиотеку. Если вы его уберете, то компилятор сразу потребует main и выдаст ошибку. 
- ```libSPACE.so``` динамические библиотеки тоже принято называть, начиная с lib (чтобы -l потом нормально работал при подстановке путей) и использовать расширение .so (shared object). Они лежат, например, в ```/lib``` (*системные, руками лучше не трогать, если не хотите переставлять линукс*) и в ```/usr/lib``` (туда можно класть свои, но с именами все равно аккуратнее). В Windows динамические библиотеки имеют расширение .dll (Dynamic Link Library). Работают аналогично. Если вы залезете в папку с любой игрой и немного в ней пошаритесь - найдете, и немало. 

Дальше давайте соберем наш исполняемый файл с динамической библиотекой (оба варианта ок, аналогично статическим библиотекам).

```g++ -o main main.cpp libSPACE.so```

```g++ -o main main.cpp -L. -lSPACE```

А теперь попробуйте запустить просто так.

```./main```

Ну да, не получилось. 
При запуске бинарника линукс будет искать нужные динамические библиотеки в системных папках. 
Вашей там, очевидно, нет.

Дальше можно идти двумя путями.
Первый громоздкий, но точно ничего не сломает.

```LD_LIBRARY_PATH=. ./main```

Тут вы явно указываете системе добавить путь ```.```, то есть текущую директорию, в список тех, где она **при этом запуске** будет искать динамические библиотеки.
То есть при следующем придется снова это писать, и вообще каждый раз. 
Очевидно, теперь она его найдет.
*Что такое LD_LIBRARY_PATH, можно почитать в конце лабы.*

Второй путь поудобнее, но требует **sudo** и сопряженной с ним ответственности.
Вы можете скопировать эту библиотеку в папку ```/usr/lib``` - главное, следите, чтобы названия не пересеклись.
И удалите потом. Тоже осторожно.

```ls /usr/lib/libSPACE.so``` - проверка, есть ли такой файл в системной папке. 
Если есть, то придумайте более ~упоротое~ оригинальное название, снова проверьте наличие, и только тогда копируйте.

```sudo cp libSPACE.so /usr/lib```

```./main``` - теперь можно просто запускать, библиотеку он найдет в системной папке.

```sudo rm /usr/lib/libSPACE.so```

Большая часть сложностей со сборкой, когда вы используете какие-то готовые пакеты, связана именно с путями.
Поэтому постарайтесь строить в голове как бы виртуальную карту, что у вас где лежит.
Пригодится.

### 3. Немного кругозора - если у вас осталась Windows.
В плане сборки с динамическими библиотеками Windows, как ни странно, немного человечнее, и ```.``` - это по умолчанию один из путей, где система будет искать .dll.
Если вы помните, как работали в прошлом семестре с SFML, то можете помнить и финальный этап установки библиотеки - копирование нужных .dll (а чаще и просто всех, на всякий случай) в папку рядом с .exe.
Это ровно оно и есть.
Если вы покопаетесь в папках с играми - опять же, чаще всего .dll лежат рядом с .exe.

А еще вы можете помнить, что все библиотеки SFML шли в двух вариантах.
Один для статической сборки, другой для динамической.
Теперь вы понимаете, что это означает.
И вообще, очень советуем еще раз пройтись по тем же инструкциям - теперь вы должны понимать их гораздо лучше.
*Это редкий случай, когда есть подробный и внятный мануал для разных сред разработки.
Имеет смысл изучить его подробно, чтобы потом по аналогии настраивать и более сложные зависимости.*

Потом посмотрите на разные проектные файлы. 
Они служат той же цели, что и Makefile - хранят инструкции, по которым исполняемый файл будет генериться из исходников.
Попробуйте найти аналогичные инструкции в файлах проектов - каких-то своих или из папки 03\_project\_files.
Если вы на постоянной основе пользуетесь какой-либо средой разработки, обязательно найдите, как эти инструкции выглядят в оконно-кнопочном интерфейсе.
Опять же - пригодится.

Где-то в них написано, какой будет компилятор.
У вас в системе может быть установлено несколько компиляторов - например, gcc, clang, icc (компилятор от Intel) и MSVC (компилятор от Microsoft).
В настройках проекта вы можете выбирать, каким именно компилятором вы хотите компилировать именно этот конкретный проект. 
*Может быть, это вообще будет компилятор не для С++, а для Fortran или Pascal.
Это компилируемые языки, и в них тоже могут быть многофайловые проекты.*
В Makefile вы писали его каждый раз вручную или создавали переменную (например, CXX\_COMPILER).

В файлах проектов могут быть указаны дополнительные пути к библиотекам, статическим и динамическим. 
Попробуйте найти их. 

Какие именно библиотеки подключать - тоже в этих инструкциях. 

И последнее важное, что надо найти - флаги компилятора.
Оптимизация, переключение стандартов, дебаговые символы - все из пункта 0. 
**Вот флаги особенно важно найти в вашей среде разработки.**

### 4. Библиотеки и сборка.
Попробуйте использовать библиотеки при сборке вашего проекта.
*Наверное, у вас и свой уже есть какой-то приличного размера, но можете использовать любой, в том числе корову.*
Выделите часть объектных файлов в библиотеку того или иного вида. 
Пропишите соответствующие инструкции в Makefile.
Поэкспериментируйте.

*Ничего принципиально нового, на самом деле, тут не появляется.
Просто нужно аккуратно скомбинировать инструкции с прошлой лабы и с этой.
Руками писать все в Makefile неудобно, но это хорошая практика, которая может расставить для вас по местам основные понятия.
А на следующей лабе будем уже ботать более удобные инструменты.*

### \*5. Немного больше про пути

В операционных системах есть такое понятие, как переменные окружения (переменные среды, environment variables).
Если мы говорим про линукс и скрипты bash, для вас эти переменные будут выглядеть как набор уже существующих переменных, заданный извне. 

Если вы напишете в скрипте *(или, что то же самое, в командной строке)* ```echo $HOME```, то есть вывести на экран значение переменной HOME, то bash выведет вам на экран название директории, которая считается домашней.

Полный список переменных окружения, который у вас на данный момент в вашей сессии bash, можно посмотреть командой ```env```.

Вообще говоря, у каждого процесса свой набор переменных окружения.
Дочерний процесс наследует набор переменных от родителя *(если надо, это тоже можно менять)*.
При запуске линукса первым стартует процесс init (можете найти его в диспетчере задач ```htop```), который прогоняет системные скрипты и инициализирует некоторый набор переменных окружения.
Этот процесс запускает bash, а bash запускает те команды, которые вы ему пишете.
*В реальности все сложнее, но как принципиальная схема для первого объяснения подойдет.*
Поэтому значения переменных "по умолчанию" - это то, что init когда-то подгрузил из системных скриптов, а теперь является окружением процесса bash.

Из интересных переменных, которые могут вам понадобиться:
- ```SHELL``` - путь к бинарнику bash;
- ```PWD``` - текущая директория (все время меняется - попробуйте попереходить в другие директории и запускать env оттуда);
- ```PATH``` - список всех директорий, где bash ищет бинарники (например, когда вы пишете ```cowsay I’m escaping to the one place that hasn’t been corrupted by capitalism… SPACE!```, он будет идти по всем директориям из PATH и искать там бинарный файл с названием cowsay);
- ```LD_LIBRARY_PATH``` - список всех директорий, где bash ищет динамические библиотеки.

Можно добавлять новые переменные.
Например, чтобы ничего не сломать, можете сделать так: ```export ROCKY_HORROR_PICTURE_SHOW=$PWD```.
В ```env``` появится новая переменная, можете проверить.

Дописать в конец переменной можно так: ```ROCKY_HORROR_PICTURE_SHOW=${ROCKY_HORROR_PICTURE_SHOW}:/usr/bin```.

Удалять переменные - командой ```unset ROCKY_HORROR_PICTURE_SHOW```.

Когда потренируетесь на своих переменных и убедитесь, что правильно поняли синтаксис, можете заняться и системными переменными.

Например, ```PWD=~``` сработает так же, как ```cd ~```.

***А вот тут осторожно.***
Вы можете поменять и PATH.
Иногда это действительно нужно.
А иногда получается случайно.
Главное - помните, что эти переменные окружения являются переменными окружения bash, то есть после перезапуска консоли вернутся на место.
Если у вас wsl, то достаточно перезапустить окошечко с wsl. 
Даже ```wsl --shutdown```, которая перезапустит все с нуля, в том числе init, делать необязательно.
Если у вас обычный линукс, то вы тоже просто перезапускаете окошечко с консолью.

Таким образом, для решения проблемы из пункта 2 у нас есть целых три способа, которые не требуют sudo.
- Как было озвучено выше, задать значение переменной окружения в рамках выполнения одной этой команды ```LD_LIBRARY_PATH=. ./main```.
- Изменить переменную для bash.
Попробуйте скомбинировать показанные вам команды.
Первым делом нужно проверить, есть ли у вас переменная LD_LIBRARY_PATH.
Если она есть, надо аккуратно дописать к ней текущую директорию.
Если ее нет, ее надо создать, записав туда текущую директорию.
Как вы уже могли понять, это решение будет работать в рамках одной сессии, то есть до перезапуска консоли.
*Ну или пока вы сами еще что-нибудь наворотить не решите.*
- ***Вот это вообще для смелых или аккуратных.***
Изменить переменную в том скрипте, который срабатывает при запуске системы. 
Тогда это "навсегда" - то есть до переустановки системы или пока вы сами обратно не поменяете.
Добавлять переменные для своего пользователя можно в ```~/.bashrc```.
После добавления надо либо перепустить консоль, чтобы bash загрузился с новыми значениями, либо использовать команду ```source ~/.bashrc```.
Как добавлять переменные system-wide - пока не стоит, но если уж очень хочется, то гуглите сами.

На что еще стоит обратить внимание.
Если вы записали относительный путь в переменную окружения, то он будет отсчитываться относительно точки запуска.
То есть если в ```env``` у вас ```LD_LIBRARY_PATH=.```, то из другой директории запуск уже не сработает.

Поэкспериментируйте с этими механиками. 
Главное - не сломать системные переменные в скриптах запуска. 
На всякий случай делайте бэкапы, изменяемых скриптов в том числе.

## Что сдаем
На половину плюса - рассказать теорию (что такое библиотеки, чем отличаются статические и динамические) и показать пункты 1 и 2.

На полный плюс - пункт 3 (если у вас осталась Windows) или пункт 4.

Сломать себе PATH и починить - сочувственное "хммм".

## Материалы
Наша корова: <https://github.com/Amisto/yet_another_educational_cowsay>

Ваш друг SFML: <https://www.sfml-dev.org/tutorials/2.5/>
