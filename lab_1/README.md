# Лабораторная 1
Первый шаг навстречу линуксу сделан, теперь пришло время подружиться с GitHub и C++ проектами, в которых исходный код разбросан по нескольким файлам.

## Что делаем

Учимся работать с многофайловыми проектами. Как их собирать и как организовывать коллективный доступ при совместной 
разработке.

### 0. Вводная часть.

Вам понадобятся два кусочка теории, чтобы понимать, о чем идет речь – схема репозиториев git/Github и схема 
многофайловой сборки.
Внимательно слушайте препа в начале лабы и задавайте вопросы.
Если пропустили – попросите одногруппников пересказать, это и им будет полезно.

#### git

Вот [тут](https://github.com/cyberspacedk/Git-commands#%D0%BA%D0%BE%D0%BD%D1%81%D0%BE%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D1%8B)
база по git, да еще и на русском. Используйте как справку. Нужные команды со всеми флагами и примерами применения можно 
сразу искать там, в табличку ниже вынесены основные команды, которые и понадобятся в данной лабе. (Не являются пошаговой интсрукцией, задание по лабе см. под табличками)

|Команда|Описание|
|----------------|:----------------|
| <pre lang="bash"><code>git clone \*адрес вашего репозитория*</code></pre> | Клонировать удаленный репозиторий в одноименную директорию |
| <pre lang="bash"><code>git pull</code></pre> | Забрать изменения с удаленного репозитория и влить в локальный |
| <pre lang="bash"><code>git fetch</code></pre><pre lang="bash"><code>git merge</code></pre> | То же, что и предыдущий, но отдельными этапами: <br> Первая команда — забрать изменения с удаленного репозитория <br> Вторая — влить изменения в локальный репозиторий |
| <pre lang="bash"><code>git remote add upstream \*наш cowsay*</code></pre> | Добавить оригинальный репозиторий как upstream |
| <pre lang="bash"><code>git fetch upstream</code></pre> | Стягиваем все ветки мастер-репозитория, но пока не сливаем со своими |
| <pre lang="bash"><code>git checkout master</code></pre> | Переключаемся на ветку master своего репозитория |
| <pre lang="bash"><code>git merge upstream/master</code></pre> | Вливаем стянутую ветку master удалённого репозитория upstream в свою ветку master |
| <pre lang="bash"><code>git add text.txt</code></pre> | Добавить в индекс указанный файл (был изменён, был удалён или это новый файл) |
| <pre lang="bash"><code>git commit -m "Name of commit"</code></pre> | Зафиксировать в коммите проиндексированные изменения (закоммитить), добавить сообщение |
| <pre lang="bash"><code>git push</code></pre> | Загрузить новые коммиты из локального репозитория на удаленный |

<a id="gpp"></a>

#### Этапы сборки на примере g++

Cопроводительное [видео](https://youtu.be/J5-hrJRgrfw) со схемой сборки.

|Код|Описание|
|----------------|:----------------|
| <pre lang="bash"><code>g++ 1.cpp -o 1</code></pre> | Все этапы сразу, обычно так и делают |
| <pre lang="bash"><code>g++ 1.cpp -E -o 11.cpp</code></pre> | Препроцессинг файла 1.cpp, получившийся файл будет называться 11.cpp |
| <pre lang="bash"><code>g++ 11.cpp -c -o 1.o</code></pre> | Компиляция файла 11.cpp, получившийся бинарный файл будет называться 1.о <br>*Здесь можно влезть в ассемблерный листинг, но пока что он вам мало что скажет. Сейчас главное – понять, что именно на этом этапе «читаемый» код на плюсах превращается в «нечитаемый» машинный.* |
| <pre lang="bash"><code>g++ 1.o -o 1</code></pre> | Линковка файла 1.о, получившийся исполняемый файл будет называться 1 |
| <pre lang="bash"><code>./1</code></pre> | Запустить исполняемый файл 1 из текущей директории |
| <pre lang="bash"><code>valgrind ./1</code></pre> | Запустить исполняемый файл 1 из текущей директории под валгриндом |
| <pre lang="bash"><code>g++ 1.o 2.o -o 12</code></pre> | Линковка файлов 1.о и 2.о, получившийся исполняемый файл будет называться 12 |
| <pre lang="bash"><code>g++ 1.cpp 2.cpp -o 12</code></pre> | Все этапы сразу для двух файлов, получившийся исполняемый файл будет называться 12 |
| <pre lang="bash"><code>g++ \*.cpp -o all</code></pre> | Все этапы для всех файлов с расширением срр в текущей директории, получившийся исполняемый файл будет называться all |

<a id="clone"></a>

### 1. Собираем чужое.

Сделайте форк [проекта](https://github.com/Amisto/yet_another_educational_cowsay) и клонируйте его  к себе на машину.
Форкать – из интерфейса Github, клонировать – см. первую строку [таблички](#git) c git командами.

Затем посмотрите на [вторую табличку](#gpp). Соберите проект, проделывая все этапы руками по 
очереди. Если что-то непонятно и не получается, постарайтесь разобраться как следует, а не перебирать все 
флаги/файлы/расширения. *Это понимание пригодится потом, когда перебирать будет слишком долго.*

*Дополнительно.* 
Скорее всего, у вас уже есть какая-то IDE (Visual Studio/CLion/Code::Blocks…). Покопайтесь в ее настройках и сопоставьте 
термины/вкладки/флаги/поля с тем, что вы поняли про сборку многофайлового проекта. 
*Если вы уже работали, например, с SFML, попробуйте разобраться, какие файлы этой библиотеки 
подключаются на каком этапе.*

<a id="change"></a>

### 2. Вносим изменения.

Возвращаемся к git и [первой табличке](#git). 
Проделайте типичный рабочий цикл:
I. Скачайте из оригинального репозитория и вашего форка изменения в проекте.
I. Измените несколько файлов .cow (можно и новые добавлять).
I. Убедитесь в работоспособности измененных файлов.
I. Соберите изменения в коммит.
I. Загрузите его на сервер.
I. Отправьте автору оригинального репозитория pull request (из интерфейса Github).

<a id="our"></a>

### 3*. Создаём своё.

Если у вас уже есть свой многофайловый проект (или однофайловый, который неплохо было бы разбить на несколько), то
попробуйте проделать шаги сборки на нем вручную. И на гитхаб его залейте, если еще не.

Почините что-нибудь в [нашем cowsay](https://github.com/Amisto/yet_another_educational_cowsay) или добавьте новый 
функционал. Если нашли какие-то Issues, то можно попробовать их исправить.

## Что сдаем
Пункты [1](#clone) и [2](#change) на половину плюса.

Пункт [3\*](#our) на полный плюс.
