# Лабораторная 1
Первый шаг навстречу линуксу сделан, теперь пришло время подружиться с GitHub и C++ проектами, в которых исходный код разбросан по нескольким файлам.

## Что делаем

Учимся работать с многофайловыми проектами. Как их собирать и как организовывать коллективный доступ при совместной 
разработке.

### 0. Вводная часть.

Вам понадобятся два кусочка теории, чтобы понимать, о чем идет речь – схема репозиториев git/Github и схема 
многофайловой сборки.
Внимательно слушайте препа в начале лабы и задавайте вопросы.
Если пропустили – попросите одногруппников пересказать, это и им будет полезно.

#### git

Вот [тут](https://github.com/cyberspacedk/Git-commands#%D0%BA%D0%BE%D0%BD%D1%81%D0%BE%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D1%8B)
база по git, да еще и на русском. Используйте как справку. Нужные команды со всеми флагами и примерами применения можно 
сразу искать там, в табличку ниже вынесены основные команды, которые и понадобятся в данной лабе.

|Команда|Описание|
|----------------|:----------------|
| <pre lang="bash"><code>git clone \*адрес вашего репозитория*</code></pre> | клонировать удаленный репозиторий в одноименную директорию |
| <pre lang="bash"><code>git pull</code></pre> | забрать изменения с удаленного репозитория и влить в локальный |
| <pre lang="bash"><code>git fetch</code><br><code>git merge</code></pre> | то же, что и предыдущий, но отдельными этапами: <br> первая команда — забрать изменения с удаленного репозитория <br> вторая — влить изменения в локальный репозиторий |
| <pre lang="bash"><code>git remote add upstream \*наш cowsay*</code></pre> | добавить оригинальный репозиторий как upstream |
| <pre lang="bash"><code>git fetch upstream</code></pre> | стягиваем все ветки мастер-репозитория, но пока не сливаем со своими |
| <pre lang="bash"><code>git checkout master</code></pre> | переключаемся на ветку master своего репозитория |
| <pre lang="bash"><code>git merge upstream/master</code></pre> | вливаем стянутую ветку master удалённого репозитория upstream в свою ветку master |
| <pre lang="bash"><code>git add text.txt</code></pre> | добавить в индекс указанный файл (был изменён, был удалён или это новый файл) |
| <pre lang="bash"><code>git commit -m "Name of commit"</code></pre> | зафиксировать в коммите проиндексированные изменения (закоммитить), добавить сообщение |
| <pre lang="bash"><code>git push</code></pre> | загрузить новые коммиты из локального репозитория на удаленный |

#### Этапы сборки на примере g++
Cопроводительное [видео](https://youtu.be/J5-hrJRgrfw) со схемой сборки.

|Код|Описание|
|----------------|:----------------|
| <pre lang="bash"><code>g++ 1.cpp -o 1</code></pre> | все этапы сразу, обычно так и делают |
| <pre lang="bash"><code>g++ 1.cpp -E -o 11.cpp</code></pre> | препроцессинг файла 1.cpp, получившийся файл будет называться 11.cpp |
| <pre lang="bash"><code>g++ 11.cpp -с -o 1.o</code></pre> | компиляция файла 11.cpp, получившийся бинарный файл будет называться 1.о <br><span style="color:grey"> Здесь можно влезть в ассемблерный листинг, но пока что он вам мало что скажет. Сейчас главное – понять, что именно на этом этапе «читаемый» код на плюсах превращается в «нечитаемый» машинный.</span> |
| <pre lang="bash"><code>g++ 1.o -o 1</code></pre> | линковка файла 1.о, получившийся исполняемый файл будет называться 1 |
| <pre lang="bash"><code>./1</code></pre> | запустить исполняемый файл 1 из текущей директории |
| <pre lang="bash"><code>valgrind ./1</code></pre> | запустить исполняемый файл 1 из текущей директории под валгриндом |
| <pre lang="bash"><code>g++ 1.o 2.o -o 12</code></pre> | линковка файлов 1.о и 2.о, получившийся исполняемый файл будет называться 12 |
| <pre lang="bash"><code>g++ 1.cpp 2.cpp -o 12</code></pre> | все этапы сразу для двух файлов, получившийся исполняемый файл будет называться 12 |
| <pre lang="bash"><code>g++ \*.cpp -o all</code></pre> | все этапы для всех файлов с расширением срр в текущей директории, получившийся исполняемый файл будет называться all |


### 1. Собираем чужое.
Сделайте форк [проекта](https://github.com/Amisto/yet_another_educational_cowsay) и клонируйте его  к себе на машину.
Форкать – из интерфейса Github, клонировать – см. первую строку [таблички](####git) c git командами.

Затем посмотрите на [вторую табличку](####Этапы-сборки-на-примере-g++). Соберите проект, проделывая все этапы руками по 
очереди. Если что-то непонятно и не получается, постарайтесь разобраться как следует, а не перебирать все 
флаги/файлы/расширения. *Это понимание пригодится потом, когда перебирать будет слишком долго.*

*Дополнительно.* 
Скорее всего, у вас уже есть какая-то IDE (Visual Studio/CLion/Code::Blocks…). Покопайтесь в ее настройках и сопоставьте 
термины/вкладки/флаги/поля с тем, что вы поняли про сборку многофайлового проекта. 
<span style="color:grey">Если вы уже работали, например, с SFML, попробуйте разобраться, какие файлы этой библиотеки 
подключаются на каком этапе. </span>

### 2. Вносим изменения.
Возвращаемся к git и [первой табличке](####git). 
Проделайте типичный рабочий цикл:
I. Скачайте из оригинального репозитория и вашего форка изменения в проекте.
I. Измените несколько файлов .cow (можно и новые добавлять).
I. Убедитесь в работоспособности измененных файлов.
I. Соберите изменения в коммит.
I. Загрузите его на сервер.
I. Отправьте автору оригинального репозитория pull request (из интерфейса Github).


### 3*. Создаём своё.
Если у вас уже есть свой многофайловый проект (или однофайловый, который неплохо было бы разбить на несколько), то
попробуйте проделать шаги сборки на нем вручную. И на гитхаб его залейте, если еще не.

Почините что-нибудь в [нашем cowsay](https://github.com/Amisto/yet_another_educational_cowsay) или добавьте новый 
функционал. Если нашли какие-то Issues, то можно попробовать их исправить.

## Что сдаем
Пункты [1](###1.-Собираем-чужое.) и [2](###2.-Вносим-изменения.) на одинарный плюс.

Пункт [3\*](###3\*.-Создаём-своё.) на двойной.