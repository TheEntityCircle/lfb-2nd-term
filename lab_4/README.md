# Лабораторная 4
## Что делаем
Разбираемся с системами сборки. 
В лабе 1 вы собирали руками многофайловый проект, записывая в консоль отдельные команды.
Когда проект большой, да еще и зависит от каких-то внешних библиотек, сборка становится более длинной.
Никто не хочет каждый раз переизобретать нужную для этого последовательность команд, поэтому существуют различные средства автоматизации процесса.
Мы будем подробно разбирать утилиту **make**, которая является стандартной в линуксах. 

Вместо нее вы могли бы писать скрипты на баше или питоне, и так иногда действительно бывает проще.
Но когда вы работаете с проектами покрупнее, да еще и хотите, чтобы они запускались на разных системах, такие скрипты могут стать сложными, громоздкими и неудобными.
В итоге вы напишете свой make.
Так что лучше сразу его и используйте.
*Даже если вы хотите писать такие штуки сами и целитесь в то, чтобы коммитить в линуксы - полезно научиться тому, что уже сделано хорошо.*

### 0. Предыстория.
Освежите в своей памяти то, что вы делали в лабе 1 - схему сборки и основные консольные команды.
### 1. База. 
Посмотрите в папку 00\_hello. Там лежит hello.cpp с содержимым очевидного характера и Makefile - файл со стандартным названием, который make будет использовать как источник инструкций.
Клонируйте себе этот репозиторий и зайдите в консоли в папку hello. Там выполните команду make и запустите получившийся бинарник hello.

Makefile состоит из набора правил.
Каждое правило состоит из цели (что хотим получить), реквизитов (из чего) и команд (что делаем).
```
<цель>: <реквизиты>
        <команда 0>
        ...
        <команда n>
```
В этом маленьком Makefile одно правило, которое состоит из цели hello (название исполняемого файла), одного реквизита hello.cpp (что компилируем) и одной команды (вызываем g++ со всеми нужными флагами).
```
hello: hello.cpp
        g++ -o hello hello.cpp
```
*Из важного - тут отступы делаются табуляцией, пробелы не сработают. Внимательно читайте ошибки, которые вам выдает make.*

### 2. Многофайловый проект. 
А теперь вам в папку 01\_gk. Там лежат файлы небольшого проекта и Makefile для его сборки. Все рабочее, можно собирать командой make и запускать получившийся бинарник general\_kenobi.
```
general_kenobi: main.o general.o kenobi.o
        g++ main.o general.o kenobi.o -o general_kenobi

main.o: main.cpp general.hpp kenobi.hpp
        g++ main.cpp -c -o main.o

general.o: general.cpp general.hpp
        g++ general.cpp -c -o general.o

kenobi.o: kenobi.cpp kenobi.hpp
        g++ kenobi.cpp -c -o kenobi.o
```
Когда вы запустили make, она взяла первое правило из Makefile в текущей директории.
Там она увидела, что для выполнения этого правила ей нужны три реквизита, которые она стала искать дальше по правилам.
Нашла, выполнила, вернулась к верхнему.

В целом, make довольно умный. 
Он может выполнять только ту цель, которую сказали (например, можете написать make kenobi.o, и выполнится только указанная цель), реквизиты аккуратно обходит рекурсивно, а при изменении файлов пересобирает только те цели, которые зависят от этих изменений.

*Иногда, конечно, не очень умный. Заголовочные файлы (то есть хедеры, .hpp и .h) надо аккуратно прописывать в зависимостях, иначе будет очень больно при отладке, когда* ***вы что-то изменили,а ничего не меняется.***

Поэкспериментируйте.
Попробуйте изменять разные файлы, пересобирать проект и смотреть, какие цели вызываются.
Постройте у себя в голове схему, как работает эта система. 

### 3. Фиктивные цели. 
Перейдите в папку 02\_htgk.
Там лежит Makefile, который использует удобные стандартные механики make для сборки и установки.
Давайте разбираться.
```
.PHONY: all clean install uninstall

all: hello_there_general_kenobi

clean:
        rm *.o hello_there_general_kenobi

install:
        install ./hello_there_general_kenobi /usr/local/bin

uninstall:
        rm /usr/local/bin/hello_there_general_kenobi

general.o: ../gk/general.cpp ../gk/general.hpp
        g++ -c ../gk/general.cpp -o general.o

kenobi.o: ../gk/kenobi.cpp ../gk/kenobi.hpp
        g++ -c ../gk/kenobi.cpp -o kenobi.o

hello_there_general_kenobi: main.cpp general.o kenobi.o ../gk/general.hpp ../gk/kenobi.hpp
        g++ main.cpp general.o kenobi.o -o hello_there_general_kenobi
```
Эти механики включаются через *фиктивные цели* - все, что перечислено в первой строчке после .PHONY. 
Большинство из них вы можете назвать как угодно (поэкспериментируйте), но лучше так.
Это стандартные названия, которые будет удобно ипользовать и вам, и тем, кто будет пользоваться вашим кодом.
- all - то, что выполнится по умолчанию (если написать в командной строке просто make). 
Если эту фиктивную цель не задавать, то выполнится первое правило, а если задавать, то вот она.
- clean - очистка каталога от "мусора". Вы уже могли заметить, что всякие .о остаются валяться в папке. Иногда мешает.
- install - установка собранного проекта в систему. Как приложения/пакета. 
Обычно требует sudo, и после этого вы сможете запускать свою hello\_there\_general\_kenobi как g++ или vim, из любой директории без ./ (ваш бинарник будет буквально лежать рядом с ними).
Соответственно, с этим надо осторожно, как и со всем, что с sudo. 
**Если название вашего бинарника совпадет с каким-то уже установленным - старый перепишется. Будьте аккуратными.**
*Мы резонно предполагаем, что стандартного приложения с названием hello_there_general_kenobi у вас в системе нет.* 
Директория, которая там написана (/usr/local/bin) в целом предназначена для собранного вручную. 
Но все равно постарайтесь и с ней поаккуратнее.
- uninstall - обратная операция. Удаление вашего приложения из системы. 
**Да, тут тоже надо аккуратно.**

### 4. Переменные.
В папке 03\_variables лежит пример. 
В принципе, тут переменные не особо отличаются от тех, что были в баш скриптах.
Называть можно как угодно, лучше понятным образом, и принято писать заглавными буквами.
Опять же - поэкспериментируйте.

### 5. Отработка материала.
Наверное, вы уже догадались, к чему все идет. 
Напишите Makefile для yet\_another\_educational\_cowsay.
*Если у вас по тем или иным причинам есть автосгенеренный - удалите и напишите свой. До автоматической генерации тоже доберемся, а пока что убедитесь, что правильно разобрались, как работает make.*

Писать install и uninstall тоже можно и нужно (разумеется, опять же, осторожно с системными папками).
При этом вы можете заметить, что даже после установки в системную папку ваш бинарник будет работать только из той директории, где есть ресурсы.
Для одного плюсика этого достаточно.

### 5\*. Установка и ресурсы.
С ресурсами для yet\_another\_educational\_cowsay вы можете сделать сложнее и умнее - вообще, ресурсы типа картинок, шрифтов, музыки и прочего принято класть в /usr/share.
Как вы можете помнить, оригинальный cowsay туда своих коров и клал. 
Можно сделать так же, но тогда вам надо подумать, как научить бинарник брать ресурсы из той папки, и переписать код, корректно прописывая пути.
А в Makefile вам придется, помимо копирования бинарника, копировать в нужное место ресурсы, а потом их удалять.
*Очень большие ресурсы - например, для игр - принято класть в /opt. 
Но у нас пока точно маленькие.*

### 6. Latex.
Вообще, make подходит не только для сборки плюсового кода.
С его помощью можно организовывать, как баш-скриптом, и более общие цепочки действий.
Чем это лучше обычных скриптов? 
Наверное, разве что стандартностью. 
Когда рядовой пользователь линукса собирает какой-то пакет из исходников, make и make install - это очень стандартные команды, которые будут использовать "по умолчанию".
Никто не хочет разбираться в тех скриптах, которые вы понаписали, даже если вы приложили README.
Все хотят писать make или даже make && make install и не думать.

Вот и вы попробуйте просто make в папке 04\_tex\_easy. 

Скорее всего, вам понядобится установить пакет для теха. 
В Ubuntu это вот так:
```
sudo apt-get install texlive-latex-base
```
Если хотите потом пользоваться им всерьез, еще вот что поставить советуют (шрифты и допвозможности):
```
sudo apt-get install texlive-fonts-recommended
sudo apt-get install texlive-fonts-extra
```
Пользоваться пакетом , то есть собирать pdf из исходников tex, потом так (в случае данной лабы вам еще картинки понадобятся, так что лучше просто make, а потом смотрите что получилось и читайте Makefile): 
```
pdflatex paper.tex

```

А потом - разберитесь в том синтаксисе, который используется для расчета имен промежуточной .png. 
Опять же, make умный и умеет жонглировать названиями файлов. 
Здесь % означает "что угодно" - при поиске реквизита (например, plot-data.png) make будет пытаться подставить его в этот шаблон (plot-%.png), и если получится(получилось), то использует его.
Далее, ```$@``` означает просто имя цели (то, что до двоеточия), а вот ```$*``` считается хитрее.
Грубо говоря, это то же, что и % - то самое "что угодно", которое при подставлении в шаблон даст имя реквизита (в данном случае, data).

Доработайте этот Makefile:
- здесь явно нужен clean, стоит с него и начать;
- добавьте несколько файлов с графиками, можете использовать свой код с прошлой лабы;
- придумайте, что еще вы хотели бы для своего личного пользования - например, автоматический сбор всех png и упаковка их в аккуратную pdf с подписями. Лучше максимально уложиться в синтаксис make, но и скрипты писать тоже можно. Как вы поняли, они могут друг друга вызывать;
- затехайте что-нибудь свое, например, какую-нибудь лабу по общефизу.

### 7. Ускорение make.
Сборка проекта - точнее, этапы препроцессинга и компиляции - отлично параллелятся. 
Это задачи, которые выполняются независимо и с разными файлами. 
Поэтому и параллельность включается максимально просто, одним флагом.

Например, следующая команда:
```
make -j4
```
распараллелит сборку на 4 потока. 
Мнемоника тут такая: j - jobs,  задачи. 
Нужно два потока - пишите флаг -j2.
Наверное, синтаксис вы поняли. 

Осталось понять, какую циферку имеет смысл писать, а какую - нет.
Скорее всего, у вас многоядерный процессор, и каждое ядро может делать свою задачу параллельно с остальными.
Посмотреть, сколько у вас ядер, можно в диспетчере задач Windows. 
Если у вас есть wsl или просто линукс как полноценная система, можете воспользоваться командой ```lscpu```.

Вас интересуют пункты CPU(s), Thread(s) per core, Core(s) per socket, Socket(s).
CPU(s) - это то, сколько процессоров видит система.
Количество сокетов, умноженное на количество ядер (core) на один сокет, умноженное на количество тредов на одно ядро.
**Максимальное реальное ускорение, которые вы можете получить - это не количество CPU.**
Это общее количество настоящих вычислителей, физических ядер (обычно сокет один, но если у вас несколько - то это будет количество сокетов, умноженное на количество ядер на один сокет).
Виртуальные ядра (hyper-threading, Thread(s) per core) упрощают и ускоряют переключение между разными процессами (а их очень много, если посмотрите в диспетчере задач).
Но в два раза быстрее физическое ядро от этого работать не будет.

Возьмите проект, который собирается в течение какого-то ощутимого времени (например, все тот yet_another_educational_cowsay) и воспользуйтесь утилитой ```time```. 
Вот так: ```time make -j4```.
Позапускайте сборку с разным количеством потоков и проверьте, какое реальное ускорение вы получаете.
Не забывайте каждый раз делать clean, чтобы сборка начиналась полностью заново, и проверяйте каждое время по несколько раз, потому что там все-таки немаленькая погрешность.
*Можете даже скрипт написать, который это делает в цикле.*

## Что сдаем
Пункт 5 на половину плюса.

Пункт 7 и один из 5* и 6 на полный плюс. 

## Материалы
Очень большой мануал по make: <http://rus-linux.net/nlib.php?name=/MyLDP/algol/gnu_make/gnu_make_3-79_russian_manual.html#SEC1>

Наша корова: <https://github.com/Amisto/yet_another_educational_cowsay>
