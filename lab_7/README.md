# Лабораторная 7

Еще одна сложная лаба, где у вас может бомбить.
Но - максимально полезная с точки зрения практического применения. 
*Это буквально то, с чего начинается ваша работа, когда вы приходите работать в какую-нибудь лабу.*

Итак, вы подошли к концу курса. 
Чему-то вы по дороге научились, к чему-то привыкли, а с чем-то успели смириться. 
По крайней мере, есть надежда, что интерфейс консоли стал для вас более-менее родным, а жонглирование кодом из магии превратилось в оперирование некоторыми сложными, но теоретически разбираемыми на простые детали сущностями.
С этим интерфейсом вам жить еще долгое время, и он вряд ли изменится.
А если вы поняли принципы сборки и подключения библиотек, то и под другими системами сможете работать, и в оконно-кнопочных интерфейсах разных IDE разбираться.
Суть везде одинаковая, и любой пакет можно собрать где угодно.
*Вопрос лишь в том, сколько седых волос вы готовы получить в процессе.*

Итак, давайте собирать разные штуки. 

## Что делаем

Собираем разные штуки.

### 0. Сборка компилятора из исходников.

Мы уже упоминали, что компилятор - это всего лишь еще одна программа.
Когда вы пишете в консоли ```g++ hello.cpp```, вы запускаете исполняемый файл с названием g++, который лежит в системной папке (можете посмотреть, где именно, командой ```which g++```) и передаете ему один аргумент из консоли (строку 'hello.cpp').
*Если в предыдущем предложении что-то непонятно, лучше спросите сразу.*

Давайте скомпилируем себе новый компилятор компилятором.

Начнем с gcc версии 12.2.0.
Скорее всего, "по умолчанию из репозитория" у вас что-то постарее, проверить это можно через ```gcc -v```.
Делается это довольно просто. 

Вот (для Ubuntu так, для других систем - внимательно читайте команды и пишите аналоги, где надо):

**Важное.** Шаг ```make -j "$(nproc)"``` делается долго (на i5-9600k было 56 мин). 
Да, сам компилятор - это очень много кода, и он долго компилируется.
Планируйте работу соответственно - например, запустите его собираться в одной вкладке терминала, а там временем делайте что-то в другой или разбирайтесь с документацией.

```
cd ~
mkdir gcc-12-source
cd gcc-12-source/
wget https://github.com/gcc-mirror/gcc/archive/refs/tags/releases/gcc-12.2.0.tar.gz
tar xzvf gcc-12.2.0.tar.gz
cd gcc-releases-gcc-12.2.0/
contrib/download_prerequisites
sudo apt install flex
mkdir build
cd build/
../configure -v --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu --prefix=/usr/local/gcc-12.2.0 --enable-checking=release --enable-languages=c,c++,fortran --program-suffix=-12.2 --disable-multilib
make -j "$(nproc)"
sudo make install-strip
```

Это довольно характерный пример набора инструкций, который вы можете встретить в интернете по запросу "g++ compiler from source".
*Или любой аналогичный запрос про установку, сборку, настройку, починку...*
Скорее всего, большую часть команд вы отсюда уже понимаете. 
Это аккуратная организация директорий, скачивание архива, распаковка, сборка и установка в систему.

Давайте немного про команды, которые могут быть непонятны:

```tar xzvf gcc-12.2.0.tar.gz``` - пока компилируется компилятор, можно немного и про tar почитать.
Для желающих - вот полная документация https://www.gnu.org/software/tar/manual/tar.html#Tutorial 
Обычно используется три основных команды/флага с говорящими названиями: -c (--create), -t (--list), -x (--extract).
Создаем, читаем содержимое, достаем.
Остальные флаги помогают уточнить, чего именно мы хотим добиться от архива. 
Сокращенные варианты флагов склеиваются вместе и порождают эти загадочные конструкции, которые вы уже видели в прошлых лабах.
Тут мы используем ```xzvf```, то есть -x (извлечь), -z (использовать gzip, потому что у нас архив .gz), -v (--verbose, побольше пишет про то, что он делает) и -f (--file, с каким архивом работаем).
Полный вариант команды выглядит так: ```tar --extract --gzip --verbose --file gcc-12.2.0.tar.gz```, делает то же самое, что и сокращенная версия.

```contrib/download_prerequisites``` - это запуск скрипта из того архива, который вы скачали и распаковали в папку.
Он за вас устанавливает недостающие пакеты, которые нужны компилятору для сборки... компилятора.
Только flex просят руками поставить (по крайней мере, для Ubuntu).
Если вы прошарились в скриптах и хотите писать многоплатформенные приложения, можно почитать и поразбирать.
Но не обязательно.

```../configure``` - аналог cmake, генерирует вам Makefile.
Многие пакеты используют его, и как пользователь вы разницы особо не заметите. 
Запустили одну команду, получили Makefile, дальше как обычно. 
*Если смотреть под капот, то сам configure - это просто bash скрипт.*
*Можете сами открыть его текстовым редактором, там прям в первой строке будет написано, что это bash скрипт.*
*Обычно они выдают справку по флагу help:* 
```../configure --help```
*Помимо базового синтаксиса, там еще используют язык макросов m4.*
*Скорее всего, по жизни вам будет достаточно cmake, но если вдруг придется работать над проектом, в котором уже configure, и коллеги не хотят переезжать - чтож.*
*Если вы поняли, как работает cmake, то и configure по гуглу освоите.*

Давайте немного про флаги, которые мы передаем в configure.
Это один из тех моментов, ради которого люди вообще связываются со сборкой компилятора из исходников - вы можете в очень широких пределах настроить себе компилятор.
Полный список здесь - https://gcc.gnu.org/install/configure.html *(о да, в очень широких пределах)*
Большая часть из них нужна при сборке под различные архитектуры. 
Если у вас Intel/AMD, и в ближайшее время вы не планируете что-то писать для мобильников или микроконтроллеров, то они вам и не понадобятся.

Давайте посмотрим, какие флаги советуют включать в этом наборе инструкций (первые три сложно, дальше попроще):

```--build=x86_64-linux-gnu``` - архитектура машины, на который мы сейчас будем собираться;

```--host=x86_64-linux-gnu``` - архитектура машины, на которой должен в итоге работать компилятор (вы можете скомпилировать компилятор на одной машине, скопировать его на другую архивчиком и там уже запускать);

```--target=x86_64-linux-gnu``` - архитектура машины, на которой будет работать то, что накомпилирует новый компилятор.

То есть, еще раз. 
У вас во всем процессе могут участвовать три разных машины с разной архитектурой.
На первой вы старым компилятором (с архитектурой build) компилируете новый (под архитектуру host).
Этот новый вы копируете на машину с архитектурой host и запускаете его, чтобы скомпилировать какой-то код (под архитектуру target).
Получаете исполняемый файл, копируете его на машину с архитектурой target и запускаете.

*Если разобрались - хорошо. Может внезапно пригодиться. Если нет, то просто запомните, что это все для сборки под микроконтроллеры. Понадобится - вернетесь сюда или просто нагуглите.*

```--prefix=/usr/local/gcc-12.2.0``` - указываем системную директорию, куда будем ставить компилятор (в прошлой лабе, когда ставили gmsh, использовали директорию в ~, но компилятор можно поставить и поближе к системе).

```--enable-checking=release``` - включаем внутренние проверки компилятора компилятором (работает, только если вы gcc компилируете с помощью gcc). 
Если что-то не склеилось, пусть лучше выдаст ошибку, будем чинить.
*Будем честны, просто скачаем архив с другой версией...*

```--enable-languages=c,c++,fortran``` - *и вот, мы коварно заставили вас поставить себе фортран.*
Просто включаете те языки, которые вам нужны - из интересного, там есть еще Ada, D и Go.

```--program-suffix=-12.2``` - это чтобы все компиляторы (в смысле под ту стопку языков, которую вы написали выше) были с удобным суффиксом и отличались от обычных системных.

```--disable-multilib``` - отключает сборку на несколько архитектур.
В нашем случае это влияет, главным образом, на то, что мы отключаем поддержку 32битного кода.
Если он вам по каким-то причинам понадобится - соберете компилятор заново с его поддержкой. 
*Например, на Ubuntu 20.04 это делается легко, а на Ubuntu 22.04 придется доставить зависимостей.*
А пока что вам надо посмотреть от начала до конца хотя бы один вариант сборки компилятора и последующей работы с ним, так что сейчас просто отключаем.

```make -j "$(nproc)"``` - количество процессоров можно определять не только вручную, но и с помощью системной переменной.

И последняя команда:

```sudo make install-strip``` - установка в систему. Отличается от ```sudo make install``` тем, что вычищает из бинарника дебаговые символы и прочие лишние отладочные штуки. 

Итак, можете ставить. 

Когда поставите, для удобства можете прописать новый компилятор в ```~/.bashrc``` - как вы можете помнить, это скрипт, который срабатывает при запуске баша.
Без этого вам придется каждый раз указывать полный путь до бинарника, типа ```/usr/local/gcc-12.2.0/bin/g++-12.2 hello.cpp``` (так жить можно, но зачем).
Прописывать в bashrc вот это (лучше в конец):

```
export PATH=/usr/local/gcc-12.2.0/bin:$PATH
export LD_LIBRARY_PATH=/usr/local/gcc-12.2.0/lib64:$LD_LIBRARY_PATH

# To let CMake know
export CC=/usr/local/gcc-12.2.0/bin/gcc-12.2
export CXX=/usr/local/gcc-12.2.0/bin/g++-12.2
export FC=/usr/local/gcc-12.2.0/bin/gfortran-12.2
```

Как вы видите, мы немного дописали в переменную PATH и создали пару переменных, чтобы было более удобно cmake.

Собственно, все. 
Можно пользоваться.
В папке ```00_XX_standard_fox``` лежат небольшие кусочки кода с cppreference, которые используют новые стандарты. 
Попробуйте сами разобраться с флагами и убедиться, что со старым компилятором они не работают, а с новым работают.
*Ну, если у вас старый компилятор был действительно старым. Если старый компилятор и сам был вполне новым, вау-фактора поменьше, но все равно проверьте его работоспособность.*

*А не забыли перезапустить bash после переписывания bashrc?..*

Небольшое дополнительное замечание. 
Вообще, компиляцию компилятора рекомендуют проводить в два этапа. 
Вначале вы старым компилятором компилируете промежуточный.
Потом промежуточным вы из тех же исходников компилируете новый.
Промежуточный и новый, *скорее всего*, не будут отличаться в плане качества результата - но новый может сам работать побыстрее, потому что скомпилирован... не поверите, более новым компилятором.

### 1. Сборка python из исходников.

Давайте попробуем собрать самый свежий питон и пару библиотек к нему из исходников. 
На практике, "самый свежий питон" - не самая практичная штука.
И не только потому, что это "early developer preview".
У питона нет обратной совместимости, и вы часто будете сталкиваться с тем, что одни пакеты работают только для одной версии питона (например, 3.8), а другие - только для другой (например, 3.9).
Поэтому читайте документацию, смотрите по ситуации и, при необходимости, допиливайте код напильником.

Как бы то ни было, давайте соберем вам последнюю версию и настроим так, чтобы вы могли выбирать ту, которая вам нужна. 
Тогда вы и любую другую соберете по аналогии.

Опять же, вначале последовательность действий, потом объяснение.

```
mkdir ~/python-3.12-source
cd ~/python-3.12-source
wget https://www.python.org/ftp/python/3.12.0/Python-3.12.0a7.tar.xz
tar xf Python-3.12.0a7.tar.xz
cd Python-3.12.0a7/
mkdir build
cd build
sudo CC=/usr/local/gcc-12.2.0/bin/gcc-12.2  CXX=/usr/local/gcc-12.2.0/bin/g++-12.2 ../configure --prefix=/opt/python/3.12.0a7/ --enable-optimizations 
sudo make -j "$(nproc)"
sudo make altinstall
```

И, опять же, большая часть инструкций вам уже понятна. 
Организуем директории, качаем, собираем.
Давайте посмотрим на важные отличия от прошлого пункта.

Перед configure мы явным образом написали, каким компилятором хотим компилировать интерпретатор питона.
*Если не поняли предыдущую фразу, перечитайте еще раз или спросите.*
А раз уж мы только что постарались и поставили себе свежий компилятор, давайте им и воспользуемся.

Флаг --prefix работает так же, как для компилятора gcc.
И у остальных флагов та же идея - настроить интерпретатор под свои нужды, полный список тут: https://docs.python.org/3/using/configure.html

```sudo make altinstall``` - у питона есть разные варианты установки. Можете набрать ```sudo make``` и понажимать Tab, он вам покажет все варианты. 

Теперь, если все сработало, вы можете что-нибудь запустить.
Например, сам питон: ```/opt/python/3.12.0a7/bin/python3.12```
Первой строчкой он выдаст вам свою версию и версию компилятора, которым он был скомпилирован. 
Если там GCC не 12.2, а старая версия из системы, которая подтянулась по умолчанию - придется руками удалить и сделать заново, внимательно следя за всеми шагами. 
Раз уж поставили новый компилятор, давайте им правильно пользоваться даже в сложных случаях.

А теперь поставим на новый питон какой-нибудь пакет из репозитория.
Путь пока пишем полный, чтобы было более наглядно - это новый интерпретатор, он лежит вот в этой папке.

```
/opt/python/3.12.0a7/bin/pip3.12 install Faker
```

Запустите с помщью нового интерпретатора скрипт ```/opt/python/3.12.0a7/bin/python3.12 01_faker/fakering.py``` и убедитесь, что все работает.

А теперь, чтобы было не столь наглядно, но удобно, давайте добавим новый питон в PATH.
Как и с компилятором, для этого надо добавить папку bin в ```~/.bashrc```:

```
export PATH=/opt/python/3.12.0a7/bin:$PATH
```

Перезапустите bash, чтобы изменения подгрузились, и попробуйте запустить тот же скрипт через ```python3.12```.

### 2. Сборка библиотеки на питоне из исходников (очень жестокий пункт даже для второго плюсика).

Давайте соберем scipy - оч хорошая и полезная библиотека.
Прям последнюю версию с гитхаба.
Делается это просто - клонируем репозиторий и с помощью pip устанавливаем из появившейся папки.

```
mkdir ~/scipy-source
cd ~/scipy-source
git clone https://github.com/scipy/scipy
cd scipy
pip3.12 install .
```

Ой. Ошибки. Что-то не так с numpy.
Давайте поставим его отдельно.

```
pip3.12 install numpy
```

Те же ошибки, только красным.

...

Дорабатываем код напильником или ждем, пока авторы пакета допилят его до питона 3.12.
Пока что мы остались без numpy и, соответственно, без scipy.

Ну ладно, давайте хоть на тот питон, что был в системе, этот последний scipy накатим. 
*Если в системе его еще нет, то поставьте, еще пригодится (для Ubuntu - ```sudo apt install python3```)*
Скорее всего, вам приедет Python 3.8 - можете проверить сами, запустив просто ```python3```.

В той же папке с исходниками scipy (если вы зачем-то оттуда ушли, вернитесь) сделайте ```pip3 install .```

И, если у вас Python 3.8, то точно ой. 
Нужен 3.9.

Печально устанавливаем старую стабильную версию из репозитория ```pip3 install scipy```
Опять же, если у вас Ubuntu, вам приедет 1.10.1.
Давайте посмотрим по документации, насколько она стара (https://docs.scipy.org/doc/scipy-1.10.1/)

...

Date: February 19, 2023 Version: 1.10.1

Вообще-то, не так уж и стара. 
Вообще не стара.
Последний стабильный релиз, новее только dev (текущее состояние проекта на гитхабе).

Старый питон настроили, теперь там есть scipy. 
Но мы-то хотим на новый.
Давайте попробуем тоже из репозитория ```pip3.12 install scipy```

Ну, если оно у вас до того не работало, то не сработает и сейчас - numpy-то и из репозитория не ок.

Окей, гугл, numpy из исходников. 
Сделайте сами по аналогии с scipy, ссылка вот: https://github.com/numpy/numpy

Если получилось, прекрасно.
Если нет...

...

...значит, нет.

Это была наглядная демонстрация того, с чем вы можете столкнуться при использовании модулей питона. 
Клеить версии самих модулей придется постоянно, да и держать под рукой несколько версий самого питона - распространенная практика.
Поэтому смотрите внимательно на циферки версий, когда что-то ставите или собираете для питона - это правда бывает важно.

Например, сейчас, если вы хотите иметь максимально свежую scipy, вам придется поставить Python 3.9.
Проще всего - из стандартного репозитория (на Ubuntu ```sudo apt install python3.9```).

А потом попробовать таки собрать в этот новый питон максимально свежий scipy с гитхаба.
Что забавно, pip3.9 для него может не поставиться, а pip3 останется привязанным к Python 3.8.
Обходить это так: ```python3.9 -m pip install .```

Скорее всего, сразу оно не сработает (то есть pip сработает для 3.9, но собрать модуль не сможет). 
Попробуйте починить, руководствуясь тем, что пишет вам pip в логе ошибок. 
Но лучше сделайте следующие пункты, а потом вернитесь к этому, если очень хочется добить.
Потому что можно застрять надолго.

Итог пункта. 
У вас на машине теперь три питона, из которых самый новый scipy запустился... нигде.
А если бы вы делали все без инструкций, с нуля, то еще бы и времени убили очень много.
Тем временем, в стандартном репозитории лежит свежая стабильная версия библиотеки, которая ставится одной строкой - ```python3.9 -m pip install scipy```
Да и для 3.8 версия вполне свежая.
Такие дела.

### 3. Сборка игры из исходников.

Коротко и ясно - поставьте себе Героев 3.

Вот отсюда: https://github.com/vcmi/vcmi

Для этого вам понадобятся все знания, которые вы приобрели за этот семестр:

- как читать выдачу cmake;
- как искать и ставить недостающие пакеты (dev не забываем, не забываем);
- и как ресурсы искать и качать.

### 4. Набивание звездочек.

Наверное, после той игры вам уже ничего не страшно, но попробуйте собрать следующие пакеты:

https://github.com/FEniCS/dolfinx

https://www.salome-platform.org/?page\_id=15

https://github.com/avasyukov/gcm-3d/tree/dev <- вот это для особо крепких духом, потому что документации нет.
Собирать из ветки dev через cmake, запускать тестовый пример так: ```./build/gcm3d --data-dir . --task tasks/tests/p-wave-free-border-test.xml```

*список будет пополняться*

## Что сдаем

На половину плюса - пункт 1 (свежий питон, собранный свежим компилятором).

На полный плюс - пункты 2 или 3 (один из) и 4. 
Даже если не получилось, расскажите, что делали.  
