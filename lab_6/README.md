# Лабораторная 6
В лабе 4 вы научились писать инструкции для make - утилиты, которая умеет собирать многофайловый проект.
Наверное, вы заметили и то, что с увеличением количества файлов и усложнением зависимостей (которые надо отслеживать руками) писать инструкции становится все сложнее.
А еще бывает, что нужно добавить в проект системные библиотеки - само по себе несложно, но иногда их приходится искать в разных папках системы, и инструкции могут стать совсем громоздкими.

Другая бытовая проблема - у программистов на одном проекте могут оказаться разные среды разработки.
А то и разные операционки.
Лучше, конечно, так не делать, но если уж случилось, хотелось бы иметь инструмент, который одинаковым образом генерирует инструкции для сборки - и Makefile, и файл проекта для Code::Blocks, и для Visual Studio.

Самым распространенным на данный момент решением является **cmake**.
Давайте его и изучим.

**ВНИМАНИЕ** 
Это сложная лаба.
Скорее всего, у вас будет бомбить.
Это нормально.
В ней вам приходится иметь дело с огромным количеством мелких неудобств - со временем, к ним привыкаешь и становишься аккуратнее.
Но для этого нужно собрать много граблей своим собственным лицом. 
Постарайтесь аккуратно идти по пунктам, там этих граблей местами уже расставлено.

## Что делаем

Изучаем cmake.

### 0. Базовый cmake.

Начинаем, как обычно, с базы.
Зайдите в папку 00\_the\_smallest\_cmake\_in\_saint\_saens и посмотрите на код, который там лежит.
В hello.cpp лежит простая программа на С++, а в CMakeLists.txt - минимальный набор инструкций, который позволяет эту программу собрать.

Для начала, запустите сам cmake:

```cmake .```
или
```cmake CMakeLists.txt```
, они сработают одинаково, взяв CMakeLists.txt из текущей директории.

Посмотрите на ту кучу файлов, которая появилась у вас в папке.

Для начала, вас интересует Makefile.
Да, это такой же Makefile, как те, которые вы писали на прошлой лабе.
Попробуйте его почитать. 
Обратите внимание на предупреждение в первой же строке - этот Makefile был сгенерирован автоматически.
Из этого следует:

0. Читать глазами будет неудобно. 
1. Если вы полезете руками, можете что-то случайно сломать, и Makefile перестанет работать.
2. Если вы что-то в нем измените, то после нового запуска cmake все изменения сотрутся. В том числе и поломки.

По жизни сам Makefile глазами читают редко, а руками туда не лезут практически никогда.
Если что-то не работает, то чинят в CMakeLists.txt.

Поехали дальше.
Теперь используйте Makefile по назначению:
```make```
или 
```make all```

У вас появится исполняемый файл, запустите его и убедитесь, что он сработал.

А теперь важный момент, который лучше не пропускать. 
Почистите папку от временных файлов cmake.
*Это нужно делать, чтобы ТОЧНО очистить кэш и провести всю сборку заново - на случай, если закэшировалось что-то ошибочное и не обновляется.*
Да, вам придется делать это руками.
Короткой команды типа clean у cmake нет, а названия не позволяют сделать что-то вроде ```rm CMake*```

Неудобно?
А то. 
Давайте теперь всё сначала, но более цивилизованно.

Все временные файлы cmake принято собирать в отдельную папку, обычно так:

```
mkdir build
cd build
cmake ..
make
./hello
```

Как видите, все временные файлы остаются в папке build, которую, когда надо, можно просто удалить целиком.
И в .gitignore добавлять проще.

Можете покопаться во временных файлах. 
Например, в CMakeFiles/hello.dir лежат промежуточные файлы сборки. 
Если вы вручную запустите дополнительные цели для make (например, ```make hello.s```), он сгенерирует ассемблерный листинг и положит туда же.

### 1. Флаги компилятора.

Вообще, флаги добавляются вот так:

```set(CMAKE_CXX_FLAGS "-Wall")```
Тут мы передаем компилятору флаг ```-Wall```, который включает все предупреждения.

Если нужно несколько флагов, то просто через пробел:

```set(CMAKE_CXX_FLAGS "-O3 -Wall")```

А если в какой-то момент вы не уверены, что уже добавили, то добавить один флаг к существующим можно так:

```set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall")```

Как вы уже поняли, CMAKE_CXX_FLAGS - это переменная в скрипте.
Можно создавать свои - если что, почитать детали можно тут https://cmake.org/cmake/help/v3.0/manual/cmake-language.7.html#variables

Для некоторых флагов есть отдельные команды.

Вот так вы можете переключать стандарты:
```set(CMAKE_CXX_STANDARD 17)```
(компилятору будет передан флаг ```-std=c++17```)

### 2. Условия и системные переменные.

Еще пара полезных моментов.
Всерьез использовать cmake как язык программирования мы не будем, но упомянем, что у него есть циклы (можете нагуглить сами, если понадобится) и условия (а вот это может пригодиться скоро).

*Даже кодстайлы свои бывают, как жить-то без кодстайлов https://community.kde.org/Policies/CMake_Coding_Style*

Оператор условия часто используется для проверки системных переменных - например, если вы хотите, чтобы ваш CMakeLists.txt работал одинаково на линуксе и Windows.
Большинство команд, скорее всего, будет одинаковыми, но могут быть разные пути или способы подключения библиотек.

Делается это так:

```
if(UNIX)
    message("This is a ${CMAKE_SYSTEM_NAME} system")
elseif(WIN32)
    message("This is a Windows System")
endif()
```

Здесь ```UNIX``` и ```WIN32``` - это булевы переменные, флаги, которые cmake выставляет на старте в зависимости от вашей системы.
Если у вас линукс, то UNIX будет true, если Windows - WIN32 (ну да, даже если сама система х64, переменная все равно называется так).
Больше деталей можно почитать тут: https://gitlab.kitware.com/cmake/community/-/wikis/doc/tutorials/How-To-Write-Platform-Checks

Команда ```message``` выводит на экран сообщения, как ```echo```.
Как видите, можно использовать переменные.
```CMAKE_SYSTEM_NAME``` - это еще одна переменная, которую cmake инициализируем сам, полное название системы.
Ее тоже можно использовать для проверок, но флаги обычно удобнее.

### 3. Сборка и подключение библиотек в cmake.

Итак, посмотрите в папку 01\_simple\_static\_library.
В ней лежит код, который вы уже видели в прошлой лабе и собирали командами из консоли. 
Давайте разбираться, как сделать то же самое из cmake.

Почитайте CMakeLists.txt, который там лежит:

```project(space)``` - можно задать название проекта;

```set(SOURCE_EXE main.cpp)``` - список исходников для исполняемого файла (как вы поняли, это опять создается текстовая переменная);

```set(SOURCE_LIB goodbye.cpp anatoly.cpp cherdenko.cpp)``` - список исходников для библиотеки (несколько файлов можно через пробел);

```add_library(gac STATIC ${SOURCE_LIB})``` - создание статической библиотеки gac (название будет libgac.a);

```add_executable(main ${SOURCE_EXE})``` - создание исполняемого файла с именем main (как видите, переменную SOURCE_EXE используем);

```target_link_libraries(main gac)``` - линковка программы с библиотекой.

Воспользуйтесь инструкциями из пункта 0, соберите и запустите этот небольшой проект.

Как видите, в папке появилось оба файла - и исполняемый, и статичеческая библиотека.
Можете покопаться в папках, которые сгенерил cmake - там вы найдете и Makefile, и промежуточные объектные файлы. 

Если хотите динамическую библиотеку - просто меняете STATIC на SHARED.
Остальное так же.

### 4. Подключение внешних библиотек, которые cmake поддерживает. 

Когда вы ставите на линукс какую-то программу или библиотеку, удобнее всего это делать с помощью пакетов.
Пакет - это архив, в котором лежит набор файлов (исполняемых и конфигурационных, библиотек, ресурсов) и инструкции, что по каким папкам раскладывать.
Стандартный формат для Ubuntu (и ее потомков Mint, Pop!OS, Elementary OS) это .deb (потому что сама Ubuntu основана на Debian), для Manjaro tar.xz, для Fedora .rpm.

Чаще всего, этим занимаются пакетные менеджеры (они еще и за зависимостями сами следят).
Вы ими уже пользовались - если у вас Ubuntu, то стандартный пакетный менеджер это apt, к которому можно поставить оконный интерфейс под названием synaptic.

После установки файлы из пакета оказываются рассыпаны по соответствующим папкам системы. 
Например, бинарник cowsay после установки лежит в /usr/games или /usr/bin (можете сами проверить командой ```which cowsay```), а файлы с коровами (ресурсы) лежат в /usr/share/cowsay.

Библиотеки тоже будут лежать в системных папках.
В /lib и ее соседях /lib32, /libx32 и /lib64 лежат системные библиотеки, которые важны для функционирования самой операционки.
Пользовательские библиотеки, которые вы обычно и будете ставить, обычно лежат в /usr/lib, /usr/lib32, /usr/lib64...

А хедеры от них - в /usr/include.

*Коротко и четко про папки можно послушать тут: https://youtu.be/42iQKuQodW4*

Давайте попробуем поставить библиотеку и ей воспользоваться.

Склонируйте себе этот репозиторий: https://github.com/TheEntityCircle/spacebattle-open

Вас интересует папка profiler\_linux. 
Там есть CMakeLists.txt, который собирает небольшое консольное приложение для игры в морской бой.
*Играть вы будете не сами, а через бота - в Bot.h лежит базовая реализация, вы можете дописать что-нибудь умнее.*

Точнее, с ходу оно у вас, скорее всего, не соберется - cmake скажет вам, что не нашел библиотеку Curses.
Попробуйте собрать и убедитесь сами.
Найдите эту ошибку, она выглядит примерно так:

```
CMake Error at /usr/share/cmake-3.16/Modules/FindPackageHandleStandardArgs.cmake:146 (message):
  Could NOT find Curses (missing: CURSES_LIBRARY CURSES_INCLUDE_PATH)
```

*Это важный момент. Такую ошибку вам придется видеть еще много раз. Даже так -* ***МНОГО РАЗ***.
*Привыкайте к ее виду.*

Давайте вначале починим, а потом будем разбираться, как оно устроено в CMakeLists.txt (чтобы все работало и сразу вывод каких-то переменных добавлять можно было).
Команды приводим для Ubuntu.
Если у вас что-то другое - наверное, аналоги вы уже знаете сами или можете загуглить.

Для начала посмотрите, что из пакетов есть у вас в системе:
```apt list --installed```

Много. 
Давайте покороче - только те, где есть что-то про curses:
```apt list --installed | grep curses```

Скорее всего, что-то про curses у вас уже есть.
Например, системный ncurses-base, от которого зависят другие пакеты.
Если попытаетесь удалить через ```sudo apt remove ncurses-base```, apt будет вас предупреждать и очень внимательно допрашивать, точно ли вы знаете, что делаете.
Если хотите следующие несколько часов вдохновенно чинить себе линукс, можете попробовать удалить. 

Пакеты часто идут в двух вариантах - один вариант "для использования", а другой "для разработки".
То есть ncurses-base - это версия без файлов .h, .so или .a. 
Она не предназначена для того, чтобы подключать ее к коду. 

Версии для разработки обычно помечаются суффиксом dev или devel (в разных пакетах и дистрибутивах может быть по-разному).
Как именно называется та библиотека, которая вам нужна - лучше гуглить, а то иногда можно запутаться в версиях или дополнительных пакетах (под языки Rust или Ada, например).

В данном случае вам нужно поставить пакет ```libncurses5-dev```.
(Кто забыл - ```sudo apt install libncurses5-dev```)

*Выяснить название сами вы можете несколькими путями.*
*Самый простой - нагуглить что-то вроде "curses ubuntu package" и следовать советам незнакомцев на форумах.*
*Путь посложнее - вбить название curses в synaptic и читать описания пакетов.*
*Тут главное помнить, что вас интересует пакет с пометкой dev и, скорее всего, с самым коротким названием.*
*Путь джедая - то же самое, только в консоли.*
```apt search curses | grep curses```

После установки должно быть норм.
Вы можете проверить наличие нужных файлов:

```whereis curses.h``` 
покажет вам, где хедер;

```whereis libsurses```
найдет статическую и динамическую библиотеки.

Теперь можно собрать profiler_linux, запустить и убедиться, что он заработал.

А теперь давайте смотреть, как библиотека подключается в самом CMakeLists.txt.

Вначале cmake ищет Curses в системе:
```find_package(Curses REQUIRED)```

Если не нашла, выдает ошибку. 
Если нашла - создает стопку переменных, которые теперь будут помогать нам при дальнейшем подключении.

Хедеры мы ищем так:
```include_directories(${CURSES_INCLUDE_DIR})```
Скорее всего, это обычная системная папка, но тут уже решает не cmake, а разработчик пакета или тот, кто его ставил. 
CURSES_INCLUDE_DIR - это просто строковая переменная, вы можете вывести ее на экран с помощью message (было в примерах выше).

Библиотеки добавляем так:
```target_link_libraries(Profiler ${CURSES_LIBRARIES})```

Такой удобный поиск - это не магия.
То, какие библиотеки cmake поддерживает сам (если докапываться, то не *сам* сам, а с помощью модулей), лежит в его системной папке (/usr/share/cmake-3.16/Modules или что-то похожее).

### 5. Подключение внешних библиотек, которые cmake НЕ поддерживает.

В принципе, тоже ничего страшного - это все равно довольно удобно. 
Посмотрите в папку 02\_gmsh.
Там лежит один файл cpp и CMakeLists.txt к нему.

В файле используется библиотека gmsh - это библиотека для построения сеток с открытым исходным кодом. 
*А на своем сайте https://gmsh.info/ авторы просят процитировать их статью, если публикуете расчеты с их сетками.*
*Очень удобно, долго искать не надо.*

Если вы снова залезете в модули cmake, то увидите, что никакого FindGMSH там нет.
Придется руками.

Если у вас Ubuntu, установка, скорее всего, пройдет штатно через apt.
Попробуйте поставить сами по аналогии с curses.

*Если у вас линукс на основе Arch или что-то пошло не так, придется собирать из исходников - посмотрите, как выглядит CMakeLists.txt и переходите на следующий пункт.*

```
add_library(gmsh SHARED IMPORTED)

set_target_properties(gmsh PROPERTIES
    IMPORTED_LOCATION "/usr/lib/x86_64-linux-gnu/libgmsh.so"
    INTERFACE_INCLUDE_DIRECTORIES "/usr/include"
)

set(GMSH_LIBRARY gmsh)

target_link_libraries(basic_test_of_gmsh ${GMSH_LIBRARY})
```

В сравнении с пунктом 1, немного изменился формат add\_library - вместо списка исходников слово IMPORTED.
То есть с точки зрения cmake это внешняя библиотека, которую он импортирует.

Дальше для нее мы настраиваем пути (скорее всего, у вас они такие же - можете проверить через whereis, у вас в системе должны быть хедер gmsh.h и динамическая библиотека libgmsh.so).

Потом создаем еще одну промежуточную переменную и линкуем библиотеку к исполняемому файлу.

Соберите и запустите этот проект.
На некоторых системах он прямо окошечко вам сразу откроет, на некоторых - нет.
Если он вам ничего не показал и при запуске вылетел с ошибкой, то вы все равно можете посмотреть результат.
В папке рядом с исполняемым файлом появился файл с расширением .msh - это сетка, которую он построил. 
Вы можете ее открыть бинарником gmsh, которые установился в систему ```gmsh t1.msh``` (иногда на wsl он хочет ```sudo gmsh t1.msh```).
Если ваша система вообще не поддерживает окошечки (например, на ваш ноут еще не приехала версия Windows, где wsl сильно умная), вы можете поставить gmsh как приложение Windows (https://gmsh.info/bin/Windows/gmsh-4.11.1-Windows64.zip), и открыть t1.msh из него.

### 6. Сборка пакета из исходников.

Иногда бывает, что пакет, который вы хотите поставить, кривой.
Точнее, кривая та версия, что лежит в стандартном репозитории, или та версия, которую вы скачали.
Их настройки пишут люди, люди ошибаются, а ошибки замечают и чинят сильно не сразу.
*Добро пожаловать в мир открытой разработки.*
А иногда вам нужна более новая версия, чем та, что лежит в репозиториях.
Или какая-то конкретная - например, доставшееся вам легаси будет работать на версии 2.18, а на версиях 2.17 и 2.19 нет.
Или эту библиотеку вообще никогда ни на какие репозитории не выкладывали, и она существует только в виде кода на гитхабе.

Все эти сценарии имеют право на жизнь, и в любом случае собирать библиотеку приходится из исходного кода.
Опять же, если библиотека поддерживает cmake (а эта штука по нынешним временам очень стандартная), это довольно просто.

Давайте потренируемся на том же gmsh и соберем последнюю версию с их сайта.
Можно сделать клон с их гитхаба, но это все уже умеют. 
Давайте что-то повеселее, тем более что репозиторий бывает не всегда.

Можете зайти на сайт (https://gmsh.info/), найти и скачать архив руками из оконно-кнопочных интерфейсов.  
Можете из консоли (обычно удобно еще и в отдельной папочке это все держать, но тут вы уже сами делайте как удобно):

```
mkdir ~/gmsh-source
cd ~/gmsh-source
wget https://gitlab.onelab.info/gmsh/gmsh/-/archive/master/gmsh-master.tar.gz
```

Потом распаковать:
```tar xzvf gmsh-master.tar.gz```

Перейти в появившуюся папку и собрать библиотеку с помощью cmake.
*На команде make можете за кофе сходить, это небыстро.*
*Но, возможно, проиллюстрирует тезис, который прилагался к схеме сборки.*
*Компиляция - это МЕДЛЕННО.*

Если вы просто собрали командой ```cmake ..```, у вас появится бинарник gmsh.
И, в общем-то, все. 
Так он собирает обычную версию, а не девелоперскую.
А нам нужна девелоперская, поэтому вам надо очистить папку и запустить cmake с вот такими флагами: ```cmake -DENABLE_BUILD_DYNAMIC=1 -DCMAKE_INSTALL_PREFIX=~/gmsh-4.12.0 ..```

Если вам интересно, что за флаги - можете почитать приложенный к gmsh README.
CMakeLists.txt тоже можете почитать - он довольно большой и сложный.
Такие файлы пишутся долго, постепенно дополняясь по мере расширения функционала, добавления новых библиотек и поддержки дополнительных платформ. 
Можете, например, покопаться с истории этого: https://gitlab.onelab.info/gmsh/gmsh/-/commits/master/CMakeLists.txt

Теперь у вас есть все нужные файлы - и .h, и .so. 
Зайдите в папку 03_fresh_gmsh и пропишите правильные пути в CMakeLists.txt.
Потом соберите и запустите (тут с запуском, к сожалению, будут те же проблемы с окошечками).

Как вы могли заметить, пути не очень удобные. 
Но если вы запускали cmake с флагом ```-DCMAKE_INSTALL_PREFIX=~/gmsh-4.12.0```, у вас есть возможность сделать их удобнее.
Для начала, создайте папку ```~/gmsh-4.12.0```.
Потом вернитесь в папку build, в которой вы собирали свежую gmsh (вы ведь не забыли каждый раз создавать папку build, правда?..), и выполните там ```make install```. 
Если вы все сделали правильно, в папке ~/gmsh-4.12.0 появятся аккуратные папочки bin, include, lib и share.
*Можете покопаться в share, там документация, туториалы, примеры - прям удобно.*
Короче говоря, цивильно и аккуратно установленная библиотека, а не месиво из промежуточных файлов.

*Флаг ```-DCMAKE_INSTALL_PREFIX=~/gmsh-4.12.0``` влияет на команду make install.*
*Какой путь напишете, туда и будет инсталл.*
*Если сделать make install без указания пути cmake, он раскидает файлы по системным папкам (типа /usr/local/bin).*
*Сам он потом сможет сделать make uninstall, потому что знает, куда что клал.*
*Но если вы удалите папку сборки, то вычищать эти файлики вручную будет неудобно.*
*А если все в отдельной папке типа gmsh-4.12.0 - это удобнее и для сборки (можно в скрипте, CMakeLists.txt или даже окружении отдельную переменную создать), и для удаления, и для менеджмента (кто не жаловался, что на C:\ места не хватает...), так что лучше так.*

Итак, теперь у вас установлено две версии библиотеки.
Одна в системе, другая в своей папочке. 
Различать вы их будете по путям, которые прописываете при сборке конкретных проектов.

## Что сдаем
На половину плюса - пункт 5.
Собраться-запуститься со старой gmsh
 
На полный плюс - пункт 6.
Надо собрать свежую gmsh из исходников и подключить ее в маленький проект.

## Материалы

Большой туториал по cmake от авторов: https://cmake.org/cmake/help/latest/guide/tutorial/index.html
